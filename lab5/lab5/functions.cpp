#include "main.h"
template <class SC>
Ring<SC>::Ring() // реализация конструктора
{
    Head = nullptr; // обнуляем указатель на первый элемент
    Curr = nullptr; // обнуляем указатель на текущий элемент
    length = 0; // обнуляем количество элементов в списке
}

template <class SC>
Ring<SC>::Ring(SC x) // реализация конструктора с параметром
{
    Head = nullptr; // обнуляем указатель на первый элемент
    Curr = nullptr; // обнуляем указатель на текущий элемент
    length = 0; // обнуляем количество элементов в списке
    push(x); // добавляем в список элемент с данными, переданными в конструктор 
}

template <class SC>
Ring<SC>::Ring(const Ring<SC>& C) // реализация конструктора копий	
{
    this->Head = nullptr; // обнуляем указатель на первый элемент
    this->Curr = nullptr; // обнуляем указалель на текущий элемент
    this->length = 0; // обнуляем количество элементов в списке
    Element* p = C.Curr;	 // сохраняем указатель на текущий элемент списка 
                       // отправленного параметром в конструктор
    for (int i = 0; i < C.length; i++) // заводим цикл на количество элементов списка-параметра
    {
        push(p->data); // добавляем в список текущий элемент списка-параметра
        p = p->next; // переходим к следующему элементу списка-параметра
    }
}

template <class SC>
Ring<SC>::~Ring() // реализация деструктора 
{
    clear(); // очистить список
}

template <class SC>
int Ring<SC>::isNoEmpty() // реализация проверки списка на наличие элементов
{
    if (Curr == nullptr) // если текущая позиция имеет нулевое значение
        return 0; // вернуть "ложь"
    else // иначе
        return 1; // вернуть "истина"
}
template <class SC>
int Ring<SC>::getlength()
{
    return(int)length;
}

template <class SC>
void Ring<SC>::init() //  приведения списка к состоянию текущий элемент - первый не удаленный 
{
    Curr = Head; // устанавливаем текущий элемент на первый не удаленный
}

template <class SC>
void Ring<SC>::delFromData(SC adr) // реализация удаления элемента списка с поиском по содержимому
{
    if (isNoEmpty())	// если список не пуст
    {
        Element* tmp = Curr; // сохранить указатель на текущую позицию в списке
        for (int i = 0; i < length * length; i++)  // завести цикл на количество элементов
        {
            if (Curr->data == adr) // если содержимое текущего элемента - искомое
            {
                if (Curr == tmp) // если искомое значение находится в текущем состоянии до поиска
                    tmp = tmp->next; // установить временный указатель на следующий элемент списка
                pop(); // извлечь значение
            }
            next(); // перейти к следующему элементу
        }
        Curr = tmp;  // вернуть указатель текущего элемента на прежнее состояние
    }
}

template <class SC>
void Ring<SC>::next() // реализация перехода к следующему элементу
{
    if (isNoEmpty()) // если список не пуст
        Curr = Curr->next; // установить текущую позицию на следующую
}

template <class SC>
void Ring<SC>::prev() // реализация перехода к предыдущему элементу
{
    if (isNoEmpty()) // если список не пуст
        Curr = Curr->prev; // установить текущую позицию на предыдущую
}
template <class SC>
void Ring<SC>::push_start(SC data)//добавление в начало
{
    Element* inserted; // создать новый указатель на элемент
    inserted = new Element;	// выделить память под элемент
    inserted->data = data; // установить входной параметр в поле данных элемента
    if (!isNoEmpty()) // если список  пуст
    {
        Head = inserted; // установить указатель первого элемента на новый элемент
        Curr = inserted; // установить указатель текущего элемента на новый элемент
        Curr->next = inserted; // установить указатель следующего элемента на новый элемент
        Curr->prev = inserted; // установить указатель предыдущего элемента на новый элемент
    }
    else // если список не пуст
    {
        inserted->next = Head;
        inserted->prev = Head->prev;
        Head = inserted;
    }
    length++;
    Curr = inserted;
}

template <class SC>
void Ring<SC>::push(SC data)	// реализация добавления элемента
{
    Element* inserted; // создать новый указатель на элемент
    inserted = new Element;	// выделить память под элемент
    inserted->data = data; // установить входной параметр в поле данных элемента
    if (!isNoEmpty()) // если список  пуст
    {
        Head = inserted; // установить указатель первого элемента на новый элемент
        Curr = inserted; // установить указатель текущего элемента на новый элемент
        Curr->next = inserted; // установить указатель следующего элемента на новый элемент
        Curr->prev = inserted; // установить указатель предыдущего элемента на новый элемент
    }
    else // если список не пуст
    {
        inserted->next = Curr->next; // перенаправляем указатель следующего элемента в добавляемом
        inserted->next->prev = inserted;	// перенаправляем указатель следующего элемента на добавляемый
        Curr->next = inserted;  // перенаправляем следующий указатель на добавляемый
        inserted->prev = Curr;  // перенаправляем предыдущий добавляемого на текущий
    }
    length++; // увеличиваем количество элементов в списке
    Curr = inserted; // устанавливаем текущий указатель на добавленный
}

template <class SC>
SC Ring<SC>::pop() // реализация  извлечения текущего элемента
{
    SC tag; // переменная под возвращаемое значение
    if (!isNoEmpty()) return 0; // если список пуст вернуть "ложь"
    Element* temp = Curr; // сохраняем указатель на текущий элемент
    tag = temp->data; // присваиваем переменной значение данных текущего элемента
    if (length == 1) // если элемент единственный в списке
    {
        Head = nullptr; // обнулить значение первого элемента
        Curr = nullptr; // обнулить значение текущего элемента
    }
    else // если элемент не единственный
    {
        Curr->next->prev = Curr->prev; // связываем следующий и предыдущий
        Curr->prev->next = Curr->next; // связываем предыдущий и следующий
        Curr = Curr->next; // перенаправляем текущий элемент на следующий
    }
    if (temp == Head) // если удаляемый элемент - первый добавленный
        Head = Head->next; // перенаправить первый на следующий
    length--;  // уменьшить количество элементов
    delete temp; // удалить предыдущий текущий элемент
    return tag; // вернуть данные удаленного элемента
}

template <class SC>
void Ring<SC>::loop() // реализация вывода всех элементов списка
{
    if (isNoEmpty()) // если список не пуст
    {
        Element* tempCar = Head; // сохраняем указатель на текущий элемент
        for (int i = 0; i < length; i++) // заводим цикл на количество элементов списка
        {
            cout << tempCar->data << " "; // выводим данные текущего элемента
            tempCar = tempCar->next; // переходим к следующему элементу
        }
        cout << "\n"; // вывод терминального символа
    }
    else // если список пуст
        cout << "Ring is empty\n"; // вывести предупреждение 
}

template <class SC>
void Ring<SC>::clear() // реализация очистки всего списка
{
    for (int i = 0; i < length;) // заводим цикл на количество элементов списка
        pop(); // извлекаем текущий элемент
}

template <class SC>
void Ring<SC>::operator + (SC v) // переопределение оператора суммы
{
    push(v); // добавляем параметр в список
}

template <class SC>
void Ring<SC>::sort() // реализация сортировки списка
{
    SC Temp; // временная переменная под данные
    int i, j; // счетчики цикла
    for (j = 0; j < length - 1; j++) // заводим цикл на количество элементов минус 1
    {
        init();  // устанавливаем текущую позицию на первый элемент										
        for (i = 0; i < length - 1; i++)	// заводим вложенный цикл на количество элементов минус 1
        {
            if (Curr->data > Curr->next->data) // если данные текущего элемента больше данных следующего 
            {
                Temp = pop(); // извлечь текущий
                next(); // перейти к следующему
                push(Temp);	 // вставить данные
            }
            else // если данные текущего элемента меньше данных следующего
                next(); // перейти к следующему
        }

    }
}
template <class SC>
int Ring<SC>::GetInt()// функция проверка ввода инта
{
    int res = 0;
    int chs = 0;
    do {
        res = scanf_s("%d", &chs);
        while (getchar() != '\n');
        if (!res || chs < 0) printf("Incorrect insert!\n");
    } while (chs < 0 || res != 1);
    return chs;
}
